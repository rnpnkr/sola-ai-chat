<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaming Voice Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 100%;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 300;
        }

        .connection-status {
            text-align: center;
            margin-bottom: 30px;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .connection-status.disconnected {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .connection-status.connecting {
            background: rgba(241, 196, 15, 0.3);
            color: #f1c40f;
        }

        .voice-indicator {
            text-align: center;
            margin: 30px 0;
        }

        .voice-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
        }

        .voice-circle.listening {
            background: rgba(46, 204, 113, 0.3);
            border-color: #2ecc71;
            animation: pulse-green 1.5s infinite;
        }

        .voice-circle.speaking {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
            animation: pulse-blue 1s infinite;
        }

        .voice-circle.processing {
            background: rgba(241, 196, 15, 0.3);
            border-color: #f1c40f;
            animation: spin 2s linear infinite;
        }

        .voice-circle.muted {
            background: rgba(231, 76, 60, 0.3);
            border-color: #e74c3c;
        }

        @keyframes pulse-green {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 15px rgba(46, 204, 113, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }

        @keyframes pulse-blue {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .voice-level {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 20px auto;
            width: 300px;
            overflow: hidden;
        }

        .voice-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #f1c40f, #e74c3c);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .voice-status {
            color: white;
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .voice-subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: rgba(46, 204, 113, 0.3);
            border-color: #2ecc71;
        }

        .control-btn.danger {
            background: rgba(231, 76, 60, 0.3);
            border-color: #e74c3c;
        }

        .conversation {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .conversation-item {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 10px;
            animation: fadeIn 0.3s ease;
        }

        .conversation-item.user {
            background: rgba(52, 152, 219, 0.3);
            margin-left: 20px;
            text-align: right;
        }

        .conversation-item.assistant {
            background: rgba(46, 204, 113, 0.3);
            margin-right: 20px;
        }

        .conversation-item .speaker {
            font-weight: bold;
            color: #ffd93d;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .conversation-item .message {
            color: white;
            line-height: 1.5;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings-panel h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: white;
            font-size: 14px;
        }

        .setting-slider {
            width: 120px;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffd93d;
            cursor: pointer;
        }

        .permission-prompt {
            background: rgba(241, 196, 15, 0.2);
            border: 2px solid #f1c40f;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: white;
        }

        .permission-btn {
            background: linear-gradient(45deg, #f1c40f, #ff6b6b);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .permission-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .status-bar {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            margin: 20px 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìû Streaming Voice Assistant</h1>

        <!-- Connection Status -->
        <div id="connectionStatus" class="connection-status disconnected">
            üî¥ Connecting to server...
        </div>

        <!-- Permission Prompt -->
        <div id="permissionPrompt" class="permission-prompt" style="display: none;">
            <h3>üé§ Microphone Access Required</h3>
            <p>This assistant needs microphone access for voice conversation.</p>
            <button id="enableMic" class="permission-btn">Enable Microphone</button>
        </div>

        <!-- Voice Indicator -->
        <div class="voice-indicator">
            <div id="voiceCircle" class="voice-circle muted">üîá</div>
            <div class="voice-level">
                <div id="voiceLevelFill" class="voice-level-fill"></div>
            </div>
            <div id="voiceStatus" class="voice-status">Initializing...</div>
            <div id="voiceSubtitle" class="voice-subtitle">Click the circle to mute/unmute</div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="muteBtn" class="control-btn danger">üîá Muted</button>
            <button id="clearBtn" class="control-btn">üóëÔ∏è Clear Chat</button>
            <button id="settingsBtn" class="control-btn">‚öôÔ∏è Settings</button>
        </div>

        <!-- Settings Panel -->
        <div id="settingsPanel" class="settings-panel" style="display: none;">
            <h3>‚öôÔ∏è Voice Settings</h3>
            <div class="setting-item">
                <label>Silence Timeout:</label>
                <input type="range" id="silenceTimeout" class="setting-slider" min="1" max="5" value="2" step="0.5">
                <span id="silenceValue">2.0s</span>
            </div>
            <div class="setting-item">
                <label>Volume Threshold:</label>
                <input type="range" id="volumeThreshold" class="setting-slider" min="0.01" max="0.1" value="0.03" step="0.01">
                <span id="volumeValue">0.03</span>
            </div>
            <div class="setting-item">
                <label>Auto-restart:</label>
                <input type="checkbox" id="autoRestart" checked>
            </div>
        </div>

        <!-- Conversation History -->
        <div class="conversation" id="conversation">
            <div class="conversation-item assistant">
                <div class="speaker">ASSISTANT</div>
                <div class="message">Hi! I'm ready to chat. Just start speaking!</div>
            </div>
        </div>

        <!-- Status Bar -->
        <div id="statusBar" class="status-bar">
            Ready to start conversation...
        </div>
    </div>

    <script>
        class StreamingVoiceAssistant {
            constructor() {
                this.ws = null;
                this.clientId = this.generateClientId();
                this.isListening = false;
                this.isMuted = true;
                this.isProcessing = false;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.silenceTimer = null;
                this.volumeLevel = 0;
                this.stream = null;

                // Settings
                this.silenceTimeout = 2000; // 2 seconds
                this.volumeThreshold = 0.03; // Voice detection threshold
                this.autoRestart = true;

                this.initializeElements();
                this.setupEventListeners();
                this.connect();
            }

            generateClientId() {
                return 'client_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
            }

            initializeElements() {
                this.elements = {
                    connectionStatus: document.getElementById('connectionStatus'),
                    permissionPrompt: document.getElementById('permissionPrompt'),
                    enableMic: document.getElementById('enableMic'),
                    voiceCircle: document.getElementById('voiceCircle'),
                    voiceLevelFill: document.getElementById('voiceLevelFill'),
                    voiceStatus: document.getElementById('voiceStatus'),
                    voiceSubtitle: document.getElementById('voiceSubtitle'),
                    muteBtn: document.getElementById('muteBtn'),
                    clearBtn: document.getElementById('clearBtn'),
                    settingsBtn: document.getElementById('settingsBtn'),
                    settingsPanel: document.getElementById('settingsPanel'),
                    conversation: document.getElementById('conversation'),
                    statusBar: document.getElementById('statusBar'),
                    silenceTimeout: document.getElementById('silenceTimeout'),
                    silenceValue: document.getElementById('silenceValue'),
                    volumeThreshold: document.getElementById('volumeThreshold'),
                    volumeValue: document.getElementById('volumeValue'),
                    autoRestart: document.getElementById('autoRestart')
                };
            }

            setupEventListeners() {
                // Microphone permission
                this.elements.enableMic.addEventListener('click', () => {
                    this.requestMicrophoneAccess();
                });

                // Voice circle toggle
                this.elements.voiceCircle.addEventListener('click', () => {
                    this.toggleMute();
                });

                // Control buttons
                this.elements.muteBtn.addEventListener('click', () => {
                    this.toggleMute();
                });

                this.elements.clearBtn.addEventListener('click', () => {
                    this.clearConversation();
                });

                this.elements.settingsBtn.addEventListener('click', () => {
                    this.toggleSettings();
                });

                // Settings
                this.elements.silenceTimeout.addEventListener('input', (e) => {
                    this.silenceTimeout = parseFloat(e.target.value) * 1000;
                    this.elements.silenceValue.textContent = e.target.value + 's';
                });

                this.elements.volumeThreshold.addEventListener('input', (e) => {
                    this.volumeThreshold = parseFloat(e.target.value);
                    this.elements.volumeValue.textContent = e.target.value;
                });

                this.elements.autoRestart.addEventListener('change', (e) => {
                    this.autoRestart = e.target.checked;
                });

                // Prevent accidental page close
                window.addEventListener('beforeunload', (e) => {
                    if (this.isListening) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                });
            }

            async connect() {
                const wsUrl = `ws://localhost:8000/ws/${this.clientId}`;
                this.updateConnectionStatus('connecting', 'üü° Connecting...');

                try {
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        this.updateConnectionStatus('connected', 'üü¢ Connected');
                        this.updateStatusBar('Connected to server - Ready for conversation');
                        this.requestMicrophoneAccess();
                    };

                    this.ws.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };

                    this.ws.onclose = () => {
                        this.updateConnectionStatus('disconnected', 'üî¥ Disconnected');
                        this.updateStatusBar('Disconnected - Attempting to reconnect...');

                        // Auto-reconnect after 3 seconds
                        setTimeout(() => {
                            if (this.ws.readyState === WebSocket.CLOSED) {
                                this.connect();
                            }
                        }, 3000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatusBar('Connection error - Check your server');
                    };

                } catch (error) {
                    console.error('Failed to connect:', error);
                    this.updateConnectionStatus('disconnected', 'üî¥ Connection Failed');
                }
            }

            async requestMicrophoneAccess() {
                try {
                    this.updateStatusBar('Requesting microphone access...');
                    this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                    this.elements.permissionPrompt.style.display = 'none';
                    this.setupVoiceDetection();
                    this.startListening();

                } catch (error) {
                    console.error('Microphone access denied:', error);
                    this.elements.permissionPrompt.style.display = 'block';
                    this.updateStatusBar('Microphone access required for conversation');
                }
            }

            setupVoiceDetection() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.microphone = this.audioContext.createMediaStreamSource(this.stream);

                this.analyser.fftSize = 256;
                this.microphone.connect(this.analyser);

                this.startVolumeMonitoring();
            }

            startVolumeMonitoring() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                const checkVolume = () => {
                    if (!this.audioContext) return;

                    this.analyser.getByteFrequencyData(dataArray);

                    // Calculate average volume
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / bufferLength / 255.0;
                    this.volumeLevel = average;

                    // Update UI
                    this.elements.voiceLevelFill.style.width = `${average * 100}%`;

                    // Voice detection logic
                    if (!this.isMuted && this.isListening) {
                        if (average > this.volumeThreshold) {
                            this.onVoiceDetected();
                        } else {
                            this.onSilenceDetected();
                        }
                    }

                    requestAnimationFrame(checkVolume);
                };

                checkVolume();
            }

            startListening() {
                if (!this.stream || this.isMuted) return;

                this.mediaRecorder = new MediaRecorder(this.stream);
                this.recordedChunks = [];

                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                    }
                };

                this.mediaRecorder.onstop = () => {
                    this.processRecording();
                };

                this.mediaRecorder.start();
                this.isListening = true;

                this.updateUI('listening');
                this.updateStatusBar('Listening... Start speaking');
            }

            onVoiceDetected() {
                // Clear silence timer if voice is detected
                if (this.silenceTimer) {
                    clearTimeout(this.silenceTimer);
                    this.silenceTimer = null;
                }

                // Update status if not already showing voice detected
                if (!this.elements.voiceStatus.textContent.includes('Speaking')) {
                    this.elements.voiceStatus.textContent = 'Speaking detected!';
                    this.updateStatusBar('Voice detected - Keep talking...');
                }
            }

            onSilenceDetected() {
                // Start silence timer if not already started
                if (!this.silenceTimer && this.isListening && !this.isMuted) {
                    this.elements.voiceStatus.textContent = 'Silence detected...';
                    this.updateStatusBar(`Silence detected - stopping in ${this.silenceTimeout/1000}s`);

                    this.silenceTimer = setTimeout(() => {
                        if (this.isListening && !this.isMuted) {
                            this.stopListening();
                        }
                    }, this.silenceTimeout);
                }
            }

            stopListening() {
                if (this.mediaRecorder && this.isListening) {
                    this.mediaRecorder.stop();
                    this.isListening = false;

                    // Cleanup timers
                    if (this.silenceTimer) {
                        clearTimeout(this.silenceTimer);
                        this.silenceTimer = null;
                    }

                    this.updateUI('processing');
                    this.updateStatusBar('Processing your message...');
                }
            }

            async processRecording() {
                if (this.recordedChunks.length === 0) {
                    this.restartListening();
                    return;
                }

                this.isProcessing = true;

                try {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                    const audioData = await this.blobToBase64(blob);

                    this.sendMessage({
                        type: 'audio_upload',
                        audio_data: audioData.split(',')[1]
                    });
                } catch (error) {
                    this.updateStatusBar(`Processing failed: ${error.message}`);
                    this.restartListening();
                }
            }

            restartListening() {
                if (this.autoRestart && !this.isMuted && this.stream) {
                    setTimeout(() => {
                        this.isProcessing = false;
                        this.startListening();
                    }, 1000);
                } else {
                    this.updateUI('idle');
                    this.isProcessing = false;
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;

                if (this.isMuted) {
                    // Mute
                    if (this.isListening) {
                        this.stopListening();
                    }
                    this.updateUI('muted');
                    this.elements.muteBtn.textContent = 'üîá Muted';
                    this.elements.muteBtn.classList.add('danger');
                    this.updateStatusBar('Microphone muted - Click to unmute');
                } else {
                    // Unmute
                    this.elements.muteBtn.textContent = 'üéôÔ∏è Active';
                    this.elements.muteBtn.classList.remove('danger');
                    this.elements.muteBtn.classList.add('active');
                    this.startListening();
                }
            }

            updateUI(state) {
                const states = {
                    idle: {
                        circle: { class: '', icon: 'üí¨', text: 'Ready to chat' }
                    },
                    listening: {
                        circle: { class: 'listening', icon: 'üéôÔ∏è', text: 'Listening...' }
                    },
                    processing: {
                        circle: { class: 'processing', icon: '‚öôÔ∏è', text: 'Processing...' }
                    },
                    speaking: {
                        circle: { class: 'speaking', icon: 'üîä', text: 'Assistant speaking' }
                    },
                    muted: {
                        circle: { class: 'muted', icon: 'üîá', text: 'Microphone muted' }
                    }
                };

                const currentState = states[state];
                if (currentState) {
                    this.elements.voiceCircle.className = `voice-circle ${currentState.circle.class}`;
                    this.elements.voiceCircle.textContent = currentState.circle.icon;
                    this.elements.voiceStatus.textContent = currentState.circle.text;
                }
            }

            handleMessage(message) {
                console.log('Received message:', message);

                switch (message.type) {
                    case 'status':
                        this.handleStatusMessage(message);
                        break;
                    case 'result':
                        this.handleResult(message);
                        break;
                    case 'error':
                        this.handleError(message);
                        break;
                }
            }

            handleStatusMessage(message) {
                const statusMap = {
                    'transcribing': 'Converting speech to text...',
                    'transcription_complete': 'Transcription complete',
                    'generating_response': 'AI is thinking...',
                    'response_generated': 'Response generated',
                    'generating_speech': 'Converting to speech...',
                    'completed': 'Response ready!'
                };

                const statusText = statusMap[message.status] || message.status;
                this.updateStatusBar(statusText);

                // Show intermediate results in conversation
                if (message.transcript) {
                    this.addToConversation('user', message.transcript);
                }
            }

            handleResult(message) {
                // Add user message if not already added
                if (message.transcript && !this.lastUserMessage) {
                    this.addToConversation('user', message.transcript);
                }

                // Add assistant response
                const responseText = message.ai_response || message.text;
                if (responseText) {
                    this.addToConversation('assistant', responseText);
                }

                // Play audio response
                if (message.audio_data) {
                    this.playAudioResponse(message.audio_data);
                }

                this.isProcessing = false;
                this.lastUserMessage = null;
            }

            handleError(message) {
                this.updateStatusBar(`Error: ${message.message}`);
                this.restartListening();
            }

            playAudioResponse(audioData) {
                const audioBlob = this.base64ToBlob(audioData, 'audio/mpeg');
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);

                this.updateUI('speaking');
                this.updateStatusBar('Assistant is speaking...');

                audio.play().catch(e => {
                    console.warn('Autoplay blocked:', e);
                    this.updateStatusBar('Response ready - Click to play');
                });

                audio.addEventListener('ended', () => {
                    URL.revokeObjectURL(audioUrl);
                    this.restartListening();
                });
            }

            addToConversation(speaker, message) {
                const conversationItem = document.createElement('div');
                conversationItem.className = `conversation-item ${speaker}`;
                conversationItem.innerHTML = `
                    <div class="speaker">${speaker.toUpperCase()}</div>
                    <div class="message">${message}</div>
                `;

                this.elements.conversation.appendChild(conversationItem);
                this.elements.conversation.scrollTop = this.elements.conversation.scrollHeight;

                if (speaker === 'user') {
                    this.lastUserMessage = message;
                }
            }

            clearConversation() {
                this.elements.conversation.innerHTML = `
                    <div class="conversation-item assistant">
                        <div class="speaker">ASSISTANT</div>
                        <div class="message">Conversation cleared. Ready to chat!</div>
                    </div>
                `;
            }

            toggleSettings() {
                const panel = this.elements.settingsPanel;
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }

            updateConnectionStatus(status, text) {
                this.elements.connectionStatus.className = `connection-status ${status}`;
                this.elements.connectionStatus.textContent = text;
            }

            updateStatusBar(text) {
                this.elements.statusBar.textContent = text;
            }

            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    this.updateStatusBar('Not connected to server');
                }
            }

            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(blob);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            }

            startKeepAlive() {
                setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.sendMessage({ type: 'ping' });
                    }
                }, 30000);
            }
        }

        // Initialize the application
        window.addEventListener('load', () => {
            const app = new StreamingVoiceAssistant();
            app.startKeepAlive();
        });
    </script>
</body>
</html>
