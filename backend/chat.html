<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sola AI - Modern Chat</title>
    <style>
        body {
            background: #1a1a1a;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;
            margin: 0;
            height: 100vh;
        }
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            background: #181818;
            box-shadow: 0 0 16px #0008;
        }
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 20px;
            background: #23272f;
            border-bottom: 1px solid #222;
        }
        .user-info {
            font-weight: 600;
            font-size: 1.1em;
            color: #b3d1ff;
        }
        .logout-btn {
            background: #2a2a2a;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px 18px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.2s;
        }
        .logout-btn:hover {
            background: #3b4a5c;
        }
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px 10px 20px 10px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: #181818;
        }
        .message-user {
            align-self: flex-end;
            background: #3b4a5c;
            border-radius: 18px 18px 4px 18px;
            padding: 12px 16px;
            max-width: 70%;
            word-break: break-word;
            font-size: 1.08em;
            box-shadow: 0 2px 8px #0003;
        }
        .message-ai {
            align-self: flex-start;
            background: #2a2a2a;
            border-radius: 18px 18px 18px 4px;
            padding: 12px 16px;
            max-width: 70%;
            word-break: break-word;
            font-size: 1.08em;
            box-shadow: 0 2px 8px #0003;
        }
        .input-container {
            display: flex;
            padding: 20px;
            background: #242424;
            border-top: 1px solid #333;
            align-items: center;
            justify-content: center;
        }
        .voice-btn {
            background: #4a9eff;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .voice-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .voice-status {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: #23272f;
            color: #fff;
            padding: 10px 24px;
            border-radius: 24px;
            font-size: 1.1em;
            display: none;
            z-index: 1001;
            box-shadow: 0 2px 8px #0005;
        }
        .voice-status.processing {
            background: #ff9500;
        }
        .voice-status.error {
            background: #ff4757;
        }
        .voice-status.success {
            background: #2ed573;
        }
        @media (max-width: 700px) {
            .chat-container {
                max-width: 100vw;
                border-radius: 0;
            }
            .auth-modal-content {
                min-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="user-info" id="user-info">User</div>
            <button class="logout-btn" id="logout-btn">Logout</button>
        </div>
        <div class="messages-container" id="messages"></div>
        <div class="input-container">
            <button class="voice-btn" id="voice-btn">üìû</button>
        </div>
    </div>
    <div class="auth-modal" id="auth-modal" style="display:none;">
        <div class="auth-modal-content">
            <h2>Login to Sola AI</h2>
            <input type="email" id="login-email" placeholder="Email" required>
            <input type="password" id="login-password" placeholder="Password" required>
            <button id="login-btn">Login</button>
            <div id="login-error" style="color:#ff4757; font-size:0.98em;"></div>
        </div>
    </div>
    <div class="voice-status" id="voice-status">üé§ Recording...</div>
    <script>
        // --- Auth & State ---
        let authToken = localStorage.getItem('auth_token');
        let username = localStorage.getItem('username') || 'User';
        let ws = null;
        let isRecording = false;
        let clientId = localStorage.getItem('client_id') || (Math.random().toString(36).slice(2));
        localStorage.setItem('client_id', clientId);

        // --- UI Elements ---
        const authModal = document.getElementById('auth-modal');
        const loginBtn = document.getElementById('login-btn');
        const loginError = document.getElementById('login-error');
        const userInfo = document.getElementById('user-info');
        const logoutBtn = document.getElementById('logout-btn');
        const messagesDiv = document.getElementById('messages');
        const voiceBtn = document.getElementById('voice-btn');
        const voiceStatus = document.getElementById('voice-status');

        // --- Auth Modal Logic ---
        function showAuthModal() {
            authModal.style.display = 'flex';
        }
        function hideAuthModal() {
            authModal.style.display = 'none';
        }
        function showChatInterface() {
            hideAuthModal();
            document.querySelector('.chat-container').style.display = 'flex';
            userInfo.textContent = username;
        }
        function handleLogin() {
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            loginError.textContent = '';
            fetch('/auth/signin', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            })
            .then(res => res.json().then(data => ({ ok: res.ok, data })))
            .then(({ ok, data }) => {
                if (ok) {
                    authToken = data.data.session.access_token;
                    username = data.data.user.email;
                    localStorage.setItem('auth_token', authToken);
                    localStorage.setItem('username', username);
                    showChatInterface();
                    connectWS();
                    loadChatHistory();
                } else {
                    const errorMessage = data.detail || 'Login failed';
                    loginError.textContent = errorMessage;
                    if (errorMessage.includes('Email not confirmed')) {
                        loginError.textContent += ' Please check your email and click the confirmation link.';
                    }
                }
            })
            .catch(err => {
                loginError.textContent = 'Login error: ' + err.message;
            });
        }
        loginBtn.onclick = handleLogin;
        logoutBtn.onclick = function() {
            localStorage.removeItem('auth_token');
            localStorage.removeItem('username');
            location.reload();
        };

        // --- Show Auth Modal if not logged in ---
        if (!authToken) {
            showAuthModal();
            document.querySelector('.chat-container').style.display = 'none';
        } else {
            showChatInterface();
            connectWS();
            loadChatHistory();
        }

        // --- Chat Message Functions ---
        function addMessage(type, content, isTemporary = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message-${type}`;
            messageDiv.textContent = content;
            if (isTemporary) messageDiv.id = 'temp-message';
            messagesDiv.appendChild(messageDiv);
            scrollToBottom();
        }
        function updateLastMessage(newContent) {
            const tempMsg = document.getElementById('temp-message');
            if (tempMsg) {
                console.log('üîÑ Updating temp message from:', tempMsg.textContent, 'to:', newContent);
                tempMsg.textContent = newContent;
                tempMsg.removeAttribute('id'); // Remove temp-message ID
                tempMsg.setAttribute('data-permanent', 'true'); // Mark as permanent
                console.log('‚úÖ User message made permanent');
            } else {
                console.log('‚ùå No temp message found to update');
                // Fallback: add the message if temp message is missing
                addMessage('user', newContent);
            }
        }
        function appendToLastAIMessage(content) {
            const messages = document.querySelectorAll('.message-ai');
            const lastAI = messages[messages.length - 1];
            if (lastAI) {
                lastAI.textContent += content;
            } else {
                addMessage('ai', content);
            }
        }
        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        function clearMessages() {
            messagesDiv.innerHTML = '';
        }

        // --- Chat History ---
        async function loadChatHistory() {
            try {
                const response = await fetch('/chats?token=' + authToken);
                const data = await response.json();
                clearMessages();
                // Sort chats by creation date to ensure proper order
                data.chats.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                data.chats.forEach(chat => {
                    addMessage('user', chat.user_message);
                    addMessage('ai', chat.ai_response);
                });
                // Remove any duplicates that might have been created
                removeDuplicateMessages();
            } catch (error) {
                console.error('Failed to load chat history:', error);
            }
        }

        // --- Advanced Voice Streaming Logic (from index.html, renamed) ---
        let streamingSession = null;
        let audioContext = null;
        let processor = null;
        let streamingActive = false;

        async function startStreamingTest() {
            if (streamingActive) {
                stopStreamingTest();
                return;
            }
            try {
                streamingSession = { chunks: [], startTime: Date.now() };
                ws.send(JSON.stringify({
                    type: 'audio_stream_start',
                    config: { sample_rate: 16000, channels: 1, format: 'pcm' }
                }));
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = audioContext.createMediaStreamSource(stream);
                processor = audioContext.createScriptProcessor(1024, 1, 1);
                processor.onaudioprocess = (event) => {
                    if (!streamingActive) return;
                    const inputBuffer = event.inputBuffer;
                    const audioData = inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(audioData.length);
                    for (let i = 0; i < audioData.length; i++) {
                        const sample = Math.max(-32768, Math.min(32767, Math.round(audioData[i] * 32767)));
                        pcmData[i] = sample;
                    }
                    const rawPcmBytes = new Uint8Array(pcmData.buffer);
                    const base64Audio = btoa(String.fromCharCode(...rawPcmBytes));
                    ws.send(JSON.stringify({
                        type: 'audio_chunk',
                        audio_data: base64Audio,
                        timestamp: Date.now(),
                        format: 'raw_pcm',
                        sample_rate: 16000,
                        channels: 1
                    }));
                };
                source.connect(processor);
                processor.connect(audioContext.destination);
                streamingActive = true;
                isRecording = true;
                // Update UI
                voiceBtn.classList.add('recording');
                voiceBtn.textContent = '‚èπ'; // Change to stop icon
                voiceStatus.style.display = 'block';
                streamingSession.stream = stream;
                setTimeout(() => {
                    if (streamingActive) {
                        stopStreamingTest();
                    }
                }, 10000);
            } catch (error) {
                alert(`Voice recording failed: ${error.message}`);
                streamingActive = false;
                isRecording = false;
            }
        }

        function stopStreamingTest() {
            if (!streamingActive) return;
            streamingActive = false;
            isRecording = false;
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (streamingSession && streamingSession.stream) {
                streamingSession.stream.getTracks().forEach(track => track.stop());
            }
            ws.send(JSON.stringify({ type: 'audio_stream_end' }));
            // Update UI
            voiceBtn.classList.remove('recording');
            voiceBtn.textContent = 'üìû'; // Change back to phone icon
            voiceStatus.style.display = 'none';
        }

        // Connect the voice button to streaming logic
        voiceBtn.onclick = function() {
            if (!streamingActive) {
                // Clear any previous temp messages
                const tempMsg = document.getElementById('temp-message');
                if (tempMsg) tempMsg.remove();
                // Add new recording message
                addMessage('user', 'üé§ Recording...', true);
                startStreamingTest();
            } else {
                stopStreamingTest();
            }
        };

        // --- WebSocket & Voice Logic ---
        function connectWS() {
            if (ws) ws.close();
            ws = new WebSocket(`ws://${window.location.host}/ws/${clientId}?token=${authToken}`);
            ws.onopen = () => {};
            ws.onclose = () => {};
            ws.onerror = (e) => { console.error('WebSocket error:', e); };
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                console.log('üì® WebSocket message:', msg.type, msg);
                if (msg.type === 'status') {
                    if (msg.status === 'speech_detected') {
                        voiceStatus.textContent = 'üéôÔ∏è Speech detected...';
                        voiceStatus.className = 'voice-status processing';
                    } else if (msg.status === 'stt_processing') {
                        voiceStatus.textContent = 'üîÑ Processing speech...';
                        voiceStatus.className = 'voice-status processing';
                    } else if (msg.status === 'transcription_complete') {
                        console.log('üìù Transcription complete, updating user message');
                        updateLastMessage(msg.transcript);
                        voiceStatus.textContent = 'ü§ñ AI responding...';
                        voiceStatus.className = 'voice-status processing';
                        scrollToBottom();
                        verifyMessageIntegrity();
                    } else if (msg.status === 'llm_streaming') {
                        voiceStatus.textContent = 'ü§ñ AI thinking...';
                        voiceStatus.className = 'voice-status processing';
                    }
                }
                else if (msg.type === 'token_stream') {
                    console.log('üîÑ Token stream received:', msg.content);
                    let lastAI = document.querySelector('.message-ai:last-of-type');
                    if (!lastAI) {
                        console.log('‚ûï Creating first AI message');
                        addMessage('ai', msg.content);
                    } else {
                        lastAI.textContent += msg.content;
                    }
                    verifyMessageIntegrity();
                }
                else if (msg.type === 'transcript_token') {
                    const tempMsg = document.getElementById('temp-message');
                    if (tempMsg) {
                        console.log('üìù Updating transcript token:', msg.content);
                        tempMsg.textContent = msg.content;
                    }
                }
                else if (msg.type === 'result') {
                    console.log('üèÅ Result received, cleaning up');
                    voiceStatus.style.display = 'none';
                    voiceStatus.className = 'voice-status success';
                    // Only remove temp messages that haven't been made permanent
                    const tempMsg = document.getElementById('temp-message');
                    if (tempMsg && !tempMsg.hasAttribute('data-permanent')) {
                        console.log('üóëÔ∏è Removing leftover temp message');
                        tempMsg.remove();
                    } else {
                        console.log('‚úÖ No temp message to remove');
                    }
                    if (msg.audio_data) {
                        const audio = new Audio('data:audio/mp3;base64,' + msg.audio_data);
                        audio.play();
                    }
                    verifyMessageIntegrity();
                }
                else if (msg.type === 'error') {
                    voiceStatus.textContent = '‚ùå Error: ' + msg.message;
                    voiceStatus.className = 'voice-status error';
                    setTimeout(() => {
                        voiceStatus.style.display = 'none';
                    }, 3000);
                }
            };
        }

        // --- Finalize Messages after AI response ---
        function finalizeMessages(transcript, ai_response) {
            // Remove any temporary recording message
            const tempMsg = document.getElementById('temp-message');
            if (tempMsg) {
                tempMsg.remove();
            }
            // Check if we already have these exact messages to prevent duplicates
            const messages = messagesDiv.children;
            const lastUserMsg = messages[messages.length - 2]; // Second to last
            const lastAIMsg = messages[messages.length - 1];   // Last
            // Only add user message if it's not already there
            if (!lastUserMsg || !lastUserMsg.textContent.includes(transcript)) {
                addMessage('user', transcript || 'üé§ Voice message');
            }
            // Only add AI message if it's not already there or if it's incomplete
            if (!lastAIMsg || 
                !lastAIMsg.classList.contains('message-ai') || 
                lastAIMsg.textContent !== ai_response) {
                // Remove incomplete AI message if exists
                if (lastAIMsg && lastAIMsg.classList.contains('message-ai') && 
                    lastAIMsg.textContent !== ai_response) {
                    lastAIMsg.remove();
                }
                addMessage('ai', ai_response);
            }
        }

        // Debugging helper
        function debugMessages() {
            console.log('Current messages in DOM:');
            Array.from(messagesDiv.children).forEach((msg, index) => {
                console.log(`${index}: ${msg.className} - "${msg.textContent}"`);
            });
        }

        // Remove duplicate messages after loading chat history
        function removeDuplicateMessages() {
            const messages = Array.from(messagesDiv.children);
            const seen = new Set();
            messages.forEach(msg => {
                const key = `${msg.className}-${msg.textContent}`;
                if (seen.has(key)) {
                    msg.remove();
                } else {
                    seen.add(key);
                }
            });
        }

        function verifyMessageIntegrity() {
            const userMessages = document.querySelectorAll('.message-user');
            const aiMessages = document.querySelectorAll('.message-ai');
            console.log('üîç Message integrity check:');
            console.log('  User messages:', userMessages.length);
            console.log('  AI messages:', aiMessages.length);
            Array.from(messagesDiv.children).forEach((msg, index) => {
                const type = msg.classList.contains('message-user') ? 'USER' : 'AI';
                const content = msg.textContent.substring(0, 30) + '...';
                const isTemp = msg.id === 'temp-message' ? '(TEMP)' : '';
                const isPermanent = msg.hasAttribute('data-permanent') ? '(PERMANENT)' : '';
                console.log(`  ${index}: ${type} ${isTemp}${isPermanent} - "${content}"`);
            });
        }
    </script>
</body>
</html> 